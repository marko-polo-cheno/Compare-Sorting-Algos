/*
 * Mark Chen
 * Nov 25 2018
 * This program will alow the user to make a random set of data of length 10, 100, 1000, or 5000.
 * The user can also choose to sort the set of data in ascending or descending order, based of a selected sorting method.
 * The computer will show the unsorted and sorted data, as well as the number of loops each sorting method takes.
 */

package chensortingefficiency;

import java.util.concurrent.TimeUnit;

/**
 *
 * @author mache9294
 */
public class Sort extends javax.swing.JFrame {

    /**
     * Creates new form Sort
     */
    public Sort() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        btnNumGroup = new javax.swing.ButtonGroup();
        btnGroupUpDown = new javax.swing.ButtonGroup();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        rBtn10 = new javax.swing.JRadioButton();
        rBtn100 = new javax.swing.JRadioButton();
        rBtn1000 = new javax.swing.JRadioButton();
        rBtn5000 = new javax.swing.JRadioButton();
        jLabel3 = new javax.swing.JLabel();
        listOfTypes = new javax.swing.JComboBox();
        jLabel4 = new javax.swing.JLabel();
        rBtnAscend = new javax.swing.JRadioButton();
        rBtnDescend = new javax.swing.JRadioButton();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtOriginal = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        txtSorted = new javax.swing.JTextArea();
        jLabel7 = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        txtResults = new javax.swing.JTextArea();
        btnSort = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowOpened(java.awt.event.WindowEvent evt) {
                formWindowOpened(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel1.setText("Sorting Assignment");

        jLabel2.setText("Amount of numbers to sort:");

        btnNumGroup.add(rBtn10);
        rBtn10.setText("10");

        btnNumGroup.add(rBtn100);
        rBtn100.setText("100");

        btnNumGroup.add(rBtn1000);
        rBtn1000.setText("1000");

        btnNumGroup.add(rBtn5000);
        rBtn5000.setText("5000");

        jLabel3.setText("Display numbers sorted by:");

        listOfTypes.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Selection Sort", "Bubble Sort", "Insertion Sort", "Quik Sort" }));

        jLabel4.setText("Sort Order:");

        btnGroupUpDown.add(rBtnAscend);
        rBtnAscend.setText("Ascending");

        btnGroupUpDown.add(rBtnDescend);
        rBtnDescend.setText("Descending");

        jLabel5.setText("Original Numbers:");

        jLabel6.setText("Sorted Numbers:");

        txtOriginal.setEditable(false);
        txtOriginal.setColumns(20);
        txtOriginal.setRows(5);
        jScrollPane1.setViewportView(txtOriginal);

        txtSorted.setEditable(false);
        txtSorted.setColumns(20);
        txtSorted.setRows(5);
        jScrollPane2.setViewportView(txtSorted);

        jLabel7.setText("Sort Results:");

        txtResults.setEditable(false);
        txtResults.setColumns(20);
        txtResults.setRows(5);
        jScrollPane3.setViewportView(txtResults);

        btnSort.setText("Sort");
        btnSort.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSortActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(65, 65, 65)
                        .addComponent(jLabel1))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addGap(18, 18, 18)
                                .addComponent(rBtn10)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(rBtn100)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(rBtn1000)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(rBtn5000))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel3)
                                .addGap(18, 18, 18)
                                .addComponent(listOfTypes, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel5)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel4)
                                        .addGap(18, 18, 18)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(rBtnAscend)
                                            .addComponent(rBtnDescend))))
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel6)
                                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(btnSort, javax.swing.GroupLayout.PREFERRED_SIZE, 114, javax.swing.GroupLayout.PREFERRED_SIZE))))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel7)
                            .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 385, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(20, 20, 20)
                .addComponent(jLabel1)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(rBtn10)
                    .addComponent(rBtn100)
                    .addComponent(rBtn1000)
                    .addComponent(rBtn5000)
                    .addComponent(jLabel7))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel3)
                            .addComponent(listOfTypes, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jLabel4)
                                    .addComponent(rBtnAscend))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(rBtnDescend))
                            .addComponent(btnSort, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel5)
                            .addComponent(jLabel6))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 197, Short.MAX_VALUE)
                            .addComponent(jScrollPane2))
                        .addGap(0, 5, Short.MAX_VALUE))
                    .addComponent(jScrollPane3))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    //The global variable for counting number of loops
    public int counterLoops = 0;
    //Used for temporary storage
    public int temp = 0;
    
    private void btnSortActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSortActionPerformed
        // Number of elements in array
        int amountNum = getAmountNum();

        //Makes array of data based on chosen number of elements
        int[] data = new int[amountNum];
        //Fills array with random numbers
        for (int i = 0; i < amountNum; i++) {
            data[i] = (int) (Math.random()*20001)-10000;
        }

        //Make total of 4 idenitical arrays for each sorting method
        int[] array1 = data.clone();
        int[] array2 = data.clone();
        int[] array3 = data.clone();
        int[] array4 = data.clone();
        
        //Up or down sorting preferation
        boolean ascend = true;
        if (rBtnAscend.isSelected()) {
            ascend = true;
        } else if (rBtnDescend.isSelected()) {
            ascend = false;
        }
        
        //To show original and sorted data
        printArraysToUI(data, ascend);
        
        //Variables for outputting details
        long start,timeElapsed;
        String results = "";
        String sortType;
        
        //Determine up or down method calls and iterate 4 times, once for each sorting method
        //Timer and loop counter resets each cycle
        if (ascend){
            //Cycle 4 times, changing name and sort for each method
            for (int i = 0; i < 4; i++) {
                counterLoops=0; //Reset counter
                start = System.nanoTime(); //Timer starts
                
                //Based on type, time the sort and run the sort
                if (i==0) {
                    sortType = "Selection Sort";
                    array1 = selectionSort(array1);
                } else if (i==1){
                    sortType = "Bubble Sort";
                    array2 = bubbleSort(array2);
                } else if (i==2){
                    sortType = "Insertion Sort";
                    array3 = insertionSort(array3);
                } else {
                    sortType = "Quik Sort";
                    array4 = quickSort(array4, 0, array4.length - 1);
                }
                
                // Get the time elapsed and add information to display
                timeElapsed = System.nanoTime() - start;
                
                results += sortType + ":\n";
                results += "Number of times a loop was executed:" + counterLoops +"\n";
                results += "Number of milliseconds to complete sort:" + TimeUnit.NANOSECONDS.toMillis(timeElapsed) +"\n";
            }
            
        } else {
            //Descending
            //Cycle 4 times, changing name and sort for each method
            for (int i = 0; i < 4; i++) {
                counterLoops=0; //Reset
                start = System.nanoTime(); //Timer starts
                
                //Based on type, time the sort
                if (i==0) {
                    sortType = "Selection Sort";
                    array1 = selectionSortDown(array1);
                } else if (i==1){
                    sortType = "Bubble Sort";
                    array2 = bubbleSortDown(array2);
                } else if (i==2){
                    sortType = "Insertion Sort";
                    array3 = insertionSortDown(array3);
                } else {
                    sortType = "Quik Sort";
                    array4 = quickSortDown(array4, 0, array4.length - 1);
                }
                
                // Get the time elapsed and add information to display
                timeElapsed = System.nanoTime() - start;
                
                results += sortType + ":\n";
                results += "Number of times a loop was executed:" + counterLoops +"\n";
                results += "Number of milliseconds to complete sort:" + TimeUnit.NANOSECONDS.toMillis(timeElapsed) +"\n";
            }
        }
        
        //Display the final text to the frame
        txtResults.setText(results);
        
    }//GEN-LAST:event_btnSortActionPerformed

    private void formWindowOpened(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowOpened
        //When the frame loads, make one radio button from each radio button group to be selected
        //This is an easy way to avoid errors in users not selecting any buttons
        rBtn10.setSelected(true);
        rBtnAscend.setSelected(true);
    }//GEN-LAST:event_formWindowOpened
    
    /**
     * This method prints any given array with an index preceding its respective elements
     * @param array - the array to be printed
     * @return - the formatted array that is to be displayed
     */
    public static String printArray(int[] array){
        String out = "";
        //For each index, add the index, the colon, and the stored value in element
        for (int i = 0; i < array.length; i++) {
            out+= i + " : " + array[i] + "\n";
        }
        return out;
    }
    
    /**
     * This method will sort a given array using the bubble sort method
     * @param array the array to be sorted
     * @return the sorted array
     */
    public int[] bubbleSort(int[] array){
        boolean swap = true;
        int max = array.length-1;
        //While there is a need to swap
        while (swap){
            //Set as false to end sort, which will be switched if any elements are switched
            swap = false;
            
            //loop through every pair of adjacent elements
            for (int i = 0; i<max; i++){
                //If adjacent elements in ascending order are not in order, swap
                if (array[i]>(array[i+1])){
                    //Switch places of elements our of order
                    temp = array[i];
                    array[i] = array[i+1];
                    array[i+1] = temp;
                    swap = true;
                }
                counterLoops++;
            }
            //Lowers upper bound after putting greatest index there
            max--;
        }
        return array;
    }
    
    /**
     * This method will sort a given array using the bubble sort method in reverse order
     * @param array the array to be sorted
     * @return the sorted array
     */
    public int[] bubbleSortDown(int[] array){
        boolean swap = true;
        int max = array.length-1;
        //While there is a need to swap
        while (swap){
            //Set as false to end sort, which will be switched if any elements are switched
            swap = false;
            
            //loop through every pair of adjacent elements
            for (int i = 0; i<max; i++){
                //If adjacent elements in ascending order are not in order, swap
                if (array[i]<(array[i+1])){
                    //Switch places of elements our of order
                    temp = array[i];
                    array[i] = array[i+1];
                    array[i+1] = temp;
                    swap = true;
                }
                counterLoops++;
            }
            //Lowers upper bound after putting greatest index there
            max--;
        }
        return array;
    }

    /**
     * This method implements the insertion sort method to sort data
     * @param array - the array to be sorted
     * @return - the sorted array
     */
    public int[] insertionSort(int[] array){
        //For all elements in the array
        for (int i = 0; i < array.length; i++) {
            //Element is after
            int element = array[i];
            //Spot is the index after the element
            int spot = i - 1;
            
            //Until the element before is less, insert the element into that spot
            while (spot >= 0 && array[spot] > element) {
                array[spot + 1] = array[spot];
                spot--;
                counterLoops++;
            }
            //Insert the element in the lowest position
            array[spot + 1] = element;
            
            counterLoops++;
        }
        return array;
    }
    
    /**
     * This method implements the insertion sort method to sort data in reverse order
     * @param array - the array to be sorted
     * @return - the sorted array
     */
    public int[] insertionSortDown(int[] array){
        //For all elements in the array
        for (int i = 0; i < array.length; i++) {
            //Element is after
            int element = array[i];
            //Spot is the index after the element
            int spot = i - 1;
            
            //Until the element before is greater, insert the element into that spot
            while (spot >= 0 && array[spot] < element) {
                array[spot + 1] = array[spot];
                spot--;
                counterLoops++;
            }
            //Insert the element in the lowest position
            array[spot + 1] = element;
            
            counterLoops++;
        }
        return array;
    }
    
    /**
     * Used for quick sort
     * This function takes the last element and places it at the correct index and
     * all lower values are places to the left, and greater values are placed to the right
     * @param array - the array to be sorted
     * @param low - the lower index bound
     * @param high - the higher index bound
     * @return 
     */
    public int partition(int[] array, int low, int high) {
        int pivot = array[high];
        int lowI = (low - 1);
        
        //Inbetween the bounds
        for (int i = low; i < high; i++) {
            //If current element is smaller than or equal to pivot 
            if (array[i] <= pivot) {
                lowI++;

                //swap the elements that are being compared
                temp = array[lowI];
                array[lowI] = array[i];
                array[i] = temp;
            }
            counterLoops++;
        }

        //Update the bounds 
        temp = array[lowI + 1];
        array[lowI + 1] = array[high];
        array[high] = temp;

        return lowI + 1;
    }
    
    /**
     * Used for quick sort down
     * This function takes the last element and places it at the correct index and
     * all higher values are places to the left, and lower values are placed to the right
     * @param array - the array to be sorted
     * @param low - the lower index bound
     * @param high - the higher index bound
     * @return 
     */
    public int partitionDown(int[] array, int low, int high) {
        int pivot = array[high];
        int i = (low - 1); // index of smaller element 
        
        for (int j = low; j < high; j++) {
            //If current element is smaller than or equal to pivot 
            if (array[j] >= pivot) {
                //Swap arr[i] and arr[j] 
                temp = array[i+1];
                array[i+1] = array[j];
                array[j] = temp;
                
                i++;
            }
            counterLoops++;
        }
        //Swap arr[i+1] and arr[high]
        temp = array[i + 1];
        array[i + 1] = array[high];
        array[high] = temp;

        return i + 1;
    }
    
    /**
     * This function that implements the QuickSort way of sorting
     * @param array - array to be sorted
     * @param low - start index
     * @param high - ending index
     * @return array sorted
     */
    public int[] quickSort(int[] array, int low, int high) {
        if (low < high) {
            /* partIndex is partitioning index, arr[partIndex] is  
              now at right place */
            int partIndex = partition(array, low, high);

            // Recursively sort elements before partition and after partition 
            quickSort(array, low, partIndex - 1);
            quickSort(array, partIndex + 1, high);
        }
        return array;
    }
    
    /**
     * The main function that implements the QuickSort in reverse order
     * @param array - array to be sorted
     * @param low - start index
     * @param high - ending index
     * @return array sorted
     */
    public int[] quickSortDown(int[] array, int low, int high) {
        if (low < high) {
            
            int partIndex = partitionDown(array, low, high);

            //Recursively sort elements before partition and after partition 
            quickSortDown(array, low, partIndex - 1);
            quickSortDown(array, partIndex + 1, high);
        }
        return array;
    }
    
    /**
     * Implements the Selection Sort approach to sorting
     * @param array - the array to be sorted
     * @return - the sorted array
     */
    public int[] selectionSort(int array[]) {
        int index;
        int right = array.length -1;
        for (int i = 0; i < right; i++) {
            index = i;
            
            for (int j = i+1; j <= right; j++) {
                if (array[j] <= array[index]) {
                    index = j;
                }
                counterLoops++;
            }
            
            temp = array[index];
            array[index] = array[i];
            array[i] = temp;
            
            
        }
        return array;
    }
    
    /**
     * Implements the Selection Sort approach to sorting in reverse order
     * @param array - the array to be sorted
     * @return - the sorted array
     */
    public int[] selectionSortDown(int array[]) {
        int index;
        int right = array.length -1;
        for (int i = 0; i < right; i++) {
            index = i;
            
            for (int j = i+1; j <= right; j++) {
                if (array[j] >= array[index]) {
                    index = j;
                    
                }
                counterLoops++;
            }

            temp = array[index];
            array[index] = array[i];
            array[i] = temp;
        }
        return array;
    }
    
    /**
     * This method gets the number of elements to make a random array
     * @return the number of elements desired
     */
    public int getAmountNum(){
        int amountNum=0;
        //Set number based on selection of radio button
        if (rBtn10.isSelected()) {
            amountNum = 10;
        } else if (rBtn100.isSelected()) {
            amountNum = 100;
        } else if (rBtn1000.isSelected()) {
            amountNum = 1000;
        } else if (rBtn5000.isSelected()) {
            amountNum = 5000;
        }
        return amountNum;
    }
    
    /**
     * This method gets the number of elements to make a random array
     * @param array the random array
     * @param up - the boolean determining ascending or descending
     */
    public void printArraysToUI(int[] array, boolean up){
        //Shows the original array first
        txtOriginal.setText(printArray(array));
        
        //Up or down sorting, DISPLAY the right sorted way of the data
        if (up) {
            //See the type of sort method chosen
            if (listOfTypes.getSelectedIndex()==0){
                //Selection Sort
                txtSorted.setText(printArray(selectionSort(array)));
            } else if (listOfTypes.getSelectedIndex()==1){
                //Bubble Sort
                txtSorted.setText(printArray(bubbleSort(array)));
            } else if (listOfTypes.getSelectedIndex()==2){
                //Insertion Sort
                txtSorted.setText(printArray(insertionSort(array)));
            } else {
                //Quik Sort
                txtSorted.setText(printArray(quickSort(array, 0, array.length - 1)));
            }
        } else {
            //See the type of sort method chosen - DESCENDING
            if (listOfTypes.getSelectedIndex()==0){
                //Selection Sort
                txtSorted.setText(printArray(selectionSortDown(array)));
            } else if (listOfTypes.getSelectedIndex()==1){
                //Bubble Sort
                txtSorted.setText(printArray(bubbleSortDown(array)));
            } else if (listOfTypes.getSelectedIndex()==2){
                //Insertion Sort
                txtSorted.setText(printArray(insertionSortDown(array)));
            } else {
                //Quik Sort
                txtSorted.setText(printArray(quickSortDown(array, 0, array.length - 1)));
            }
        }
        
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Sort.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Sort.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Sort.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Sort.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Sort().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup btnGroupUpDown;
    private javax.swing.ButtonGroup btnNumGroup;
    private javax.swing.JButton btnSort;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JComboBox listOfTypes;
    private javax.swing.JRadioButton rBtn10;
    private javax.swing.JRadioButton rBtn100;
    private javax.swing.JRadioButton rBtn1000;
    private javax.swing.JRadioButton rBtn5000;
    private javax.swing.JRadioButton rBtnAscend;
    private javax.swing.JRadioButton rBtnDescend;
    private javax.swing.JTextArea txtOriginal;
    private javax.swing.JTextArea txtResults;
    private javax.swing.JTextArea txtSorted;
    // End of variables declaration//GEN-END:variables
}
